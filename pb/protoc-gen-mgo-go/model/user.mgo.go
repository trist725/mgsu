// Code generated by protoc-gen-mgo-go. DO NOT EDIT IT!!!
// source: user.proto

package model

import (
	context "context"
	json "encoding/json"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	qmgo "github.com/qiniu/qmgo"
	options "github.com/qiniu/qmgo/options"
	bson "go.mongodb.org/mongo-driver/bson"
	math "math"
	msg "mlgs/src/msg"
	sync "sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = json.Marshal
var _ = msg.PH

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [Test] begin

func New_Test() *Test {
	m := &Test{}
	return m
}

func (m Test) JsonString() string {
	ba, _ := json.Marshal(m)
	return "Test:" + string(ba)
}

func (m *Test) ResetEx() {

	m.I32 = 0

	m.U32 = 0

	m.Str = ""

}

func (m Test) Clone() *Test {
	n, ok := g_Test_Pool.Get().(*Test)
	if !ok || n == nil {
		n = &Test{}
	}

	n.I32 = m.I32

	n.U32 = m.U32

	n.Str = m.Str

	return n
}

func Clone_Test_Slice(dst []*Test, src []*Test) []*Test {
	for _, i := range dst {
		Put_Test(i)
	}
	if len(src) > 0 {
		dst = make([]*Test, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		// dst = []*Test{}
		dst = nil
	}
	return dst
}

func (m Test) ToMsg(n *msg.Test) *msg.Test {
	if n == nil {
		n = msg.Get_Test()
	}

	n.i = m.I32

	n.U32 = m.U32

	n.Str = m.Str

	return n
}

type TestMap map[int64]*Test

func ToTestMap(m map[int64]*Test) *TestMap {
	if m == nil {
		return nil
	}
	return (*TestMap)(&m)
}

func NewTestMap() (m *TestMap) {
	m = &TestMap{}
	return
}

func (m *TestMap) Get(key int64) (value *Test, ok bool) {
	value, ok = (*m)[key]
	return
}

func (m *TestMap) Set(key int64, value *Test) {
	(*m)[key] = value
}

func (m *TestMap) Add(key int64) (value *Test) {
	value = Get_Test()
	(*m)[key] = value
	return
}

func (m *TestMap) Remove(key int64) (removed bool) {
	if _, ok := (*m)[key]; ok {
		delete(*m, key)
		return true
	}
	return false
}

func (m *TestMap) RemoveOne(fn func(key int64, value *Test) (removed bool)) {
	for key, value := range *m {
		if fn(key, value) {
			delete(*m, key)
			break
		}
	}
}

func (m *TestMap) RemoveSome(fn func(key int64, value *Test) (removed bool)) {
	left := map[int64]*Test{}
	for key, value := range *m {
		if !fn(key, value) {
			left[key] = value
		}
	}
	*m = left
}

func (m *TestMap) Each(f func(key int64, value *Test) (continued bool)) {
	for key, value := range *m {
		if !f(key, value) {
			break
		}
	}
}

func (m TestMap) Size() int {
	return len(m)
}

func (m TestMap) Clone() (n *TestMap) {
	if m.Size() == 0 {
		return nil
	}
	n = ToTestMap(make(map[int64]*Test, m.Size()))
	for k, v := range m {
		if v != nil {
			(*n)[k] = v.Clone()
		} else {
			(*n)[k] = nil
		}
	}
	return n
}

func (m *TestMap) Clear() {
	*m = *NewTestMap()
}

func (m TestMap) ToMsg(n map[int64]*msg.Test) map[int64]*msg.Test {
	if m.Size() == 0 {
		return nil
	}
	n = make(map[int64]*msg.Test, m.Size())
	for k, v := range m {
		if v != nil {
			n[k] = v.ToMsg(nil)
		} else {
			n[k] = msg.Get_Test()
		}
	}
	return n
}

type TestSlice []*Test

func NewTestSlice() *TestSlice {
	return &TestSlice{}
}

func ToTestSlice(s []*Test) *TestSlice {
	return (*TestSlice)(&s)
}

func (s *TestSlice) Add() *Test {
	return s.AddOne(Get_Test())
}

func (s *TestSlice) AddOne(newOne *Test) *Test {
	*s = append(*s, newOne)
	return newOne
}

func (s *TestSlice) RemoveOne(fn func(index int, element *Test) (removed bool)) {
	for i, e := range *s {
		if fn(i, e) {
			*s = append((*s)[:i], (*s)[i+1:]...)
			break
		}
	}
}

func (s *TestSlice) RemoveSome(fn func(index int, element *Test) (removed bool)) {
	var left []*Test
	for i, e := range *s {
		if !fn(i, e) {
			left = append(left, e)
		}
	}
	*s = left
}

func (s TestSlice) Each(fn func(index int, element *Test) (continued bool)) {
	for i, e := range s {
		if !fn(i, e) {
			break
		}
	}
}

func (s TestSlice) Size() int {
	return len(s)
}

func (s TestSlice) Clone() (n *TestSlice) {
	if s.Size() == 0 {
		return nil
	}
	n = ToTestSlice(make([]*Test, s.Size()))
	for i, e := range s {
		if e != nil {
			(*n)[i] = e.Clone()
		} else {
			(*n)[i] = nil
		}
	}
	return n
}

func (s *TestSlice) Clear() {
	*s = *NewTestSlice()
}

func (s TestSlice) ToMsg(n []*msg.Test) []*msg.Test {
	if s.Size() == 0 {
		return nil
	}
	n = make([]*msg.Test, s.Size())
	for i, e := range s {
		if e != nil {
			n[i] = e.ToMsg(nil)
		} else {
			n[i] = msg.Get_Test()
		}
	}
	return n
}

var g_Test_Pool = sync.Pool{}

func Get_Test() *Test {
	m, ok := g_Test_Pool.Get().(*Test)
	if !ok {
		m = New_Test()
	} else {
		if m == nil {
			m = New_Test()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_Test(i interface{}) {
	if m, ok := i.(*Test); ok && m != nil {
		g_Test_Pool.Put(i)
	}
}

// collection [Test] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [Test2] begin

func New_Test2() *Test2 {
	m := &Test2{}
	return m
}

func (m Test2) JsonString() string {
	ba, _ := json.Marshal(m)
	return "Test2:" + string(ba)
}

func (m *Test2) ResetEx() {

	m.I32 = 0

	m.U32 = 0

	for _, i := range m.Ts {
		Put_Test(i)
	}

	// m.Ts = []*Test{}
	m.Ts = nil

}

func (m Test2) Clone() *Test2 {
	n, ok := g_Test2_Pool.Get().(*Test2)
	if !ok || n == nil {
		n = &Test2{}
	}

	n.I32 = m.I32

	n.U32 = m.U32

	if len(m.Ts) > 0 {
		n.Ts = make([]*Test, len(m.Ts))
		for i, e := range m.Ts {

			if e != nil {
				n.Ts[i] = e.Clone()
			}

		}
	} else {
		// n.Ts = []*Test{}
		n.Ts = nil
	}

	return n
}

func Clone_Test2_Slice(dst []*Test2, src []*Test2) []*Test2 {
	for _, i := range dst {
		Put_Test2(i)
	}
	if len(src) > 0 {
		dst = make([]*Test2, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		// dst = []*Test2{}
		dst = nil
	}
	return dst
}

func (m Test2) ToMsg(n *msg.Test2) *msg.Test2 {
	if n == nil {
		n = msg.Get_Test2()
	}

	n.i = m.I32

	n.U32 = m.U32

	if len(m.Ts) > 0 {
		n.Ts = make([]*msg.Test, len(m.Ts))
		for i, e := range m.Ts {
			if e != nil {
				n.Ts[i] = e.ToMsg(n.Ts[i])
			} else {
				n.Ts[i] = msg.Get_Test()
			}
		}
	} else {
		// n.Ts = []*Test{}
		n.Ts = nil
	}

	return n
}

type Test2Map map[int64]*Test2

func ToTest2Map(m map[int64]*Test2) *Test2Map {
	if m == nil {
		return nil
	}
	return (*Test2Map)(&m)
}

func NewTest2Map() (m *Test2Map) {
	m = &Test2Map{}
	return
}

func (m *Test2Map) Get(key int64) (value *Test2, ok bool) {
	value, ok = (*m)[key]
	return
}

func (m *Test2Map) Set(key int64, value *Test2) {
	(*m)[key] = value
}

func (m *Test2Map) Add(key int64) (value *Test2) {
	value = Get_Test2()
	(*m)[key] = value
	return
}

func (m *Test2Map) Remove(key int64) (removed bool) {
	if _, ok := (*m)[key]; ok {
		delete(*m, key)
		return true
	}
	return false
}

func (m *Test2Map) RemoveOne(fn func(key int64, value *Test2) (removed bool)) {
	for key, value := range *m {
		if fn(key, value) {
			delete(*m, key)
			break
		}
	}
}

func (m *Test2Map) RemoveSome(fn func(key int64, value *Test2) (removed bool)) {
	left := map[int64]*Test2{}
	for key, value := range *m {
		if !fn(key, value) {
			left[key] = value
		}
	}
	*m = left
}

func (m *Test2Map) Each(f func(key int64, value *Test2) (continued bool)) {
	for key, value := range *m {
		if !f(key, value) {
			break
		}
	}
}

func (m Test2Map) Size() int {
	return len(m)
}

func (m Test2Map) Clone() (n *Test2Map) {
	if m.Size() == 0 {
		return nil
	}
	n = ToTest2Map(make(map[int64]*Test2, m.Size()))
	for k, v := range m {
		if v != nil {
			(*n)[k] = v.Clone()
		} else {
			(*n)[k] = nil
		}
	}
	return n
}

func (m *Test2Map) Clear() {
	*m = *NewTest2Map()
}

func (m Test2Map) ToMsg(n map[int64]*msg.Test2) map[int64]*msg.Test2 {
	if m.Size() == 0 {
		return nil
	}
	n = make(map[int64]*msg.Test2, m.Size())
	for k, v := range m {
		if v != nil {
			n[k] = v.ToMsg(nil)
		} else {
			n[k] = msg.Get_Test2()
		}
	}
	return n
}

type Test2Slice []*Test2

func NewTest2Slice() *Test2Slice {
	return &Test2Slice{}
}

func ToTest2Slice(s []*Test2) *Test2Slice {
	return (*Test2Slice)(&s)
}

func (s *Test2Slice) Add() *Test2 {
	return s.AddOne(Get_Test2())
}

func (s *Test2Slice) AddOne(newOne *Test2) *Test2 {
	*s = append(*s, newOne)
	return newOne
}

func (s *Test2Slice) RemoveOne(fn func(index int, element *Test2) (removed bool)) {
	for i, e := range *s {
		if fn(i, e) {
			*s = append((*s)[:i], (*s)[i+1:]...)
			break
		}
	}
}

func (s *Test2Slice) RemoveSome(fn func(index int, element *Test2) (removed bool)) {
	var left []*Test2
	for i, e := range *s {
		if !fn(i, e) {
			left = append(left, e)
		}
	}
	*s = left
}

func (s Test2Slice) Each(fn func(index int, element *Test2) (continued bool)) {
	for i, e := range s {
		if !fn(i, e) {
			break
		}
	}
}

func (s Test2Slice) Size() int {
	return len(s)
}

func (s Test2Slice) Clone() (n *Test2Slice) {
	if s.Size() == 0 {
		return nil
	}
	n = ToTest2Slice(make([]*Test2, s.Size()))
	for i, e := range s {
		if e != nil {
			(*n)[i] = e.Clone()
		} else {
			(*n)[i] = nil
		}
	}
	return n
}

func (s *Test2Slice) Clear() {
	*s = *NewTest2Slice()
}

func (s Test2Slice) ToMsg(n []*msg.Test2) []*msg.Test2 {
	if s.Size() == 0 {
		return nil
	}
	n = make([]*msg.Test2, s.Size())
	for i, e := range s {
		if e != nil {
			n[i] = e.ToMsg(nil)
		} else {
			n[i] = msg.Get_Test2()
		}
	}
	return n
}

var g_Test2_Pool = sync.Pool{}

func Get_Test2() *Test2 {
	m, ok := g_Test2_Pool.Get().(*Test2)
	if !ok {
		m = New_Test2()
	} else {
		if m == nil {
			m = New_Test2()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_Test2(i interface{}) {
	if m, ok := i.(*Test2); ok && m != nil {
		g_Test2_Pool.Put(i)
	}
}

// collection [Test2] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [User] begin

func New_User() *User {
	m := &User{

		Test: Get_Test(),
	}
	return m
}

func (m User) JsonString() string {
	ba, _ := json.Marshal(m)
	return "User:" + string(ba)
}

func (m *User) ResetEx() {

	m.ID = 0

	m.AccountID = 0

	m.ServerID = 0

	m.Name = ""

	m.Sex = 0

	m.CreateTime = 0

	// m.Arr = []int32{}
	m.Arr = nil

	// m.StrArr = []string{}
	m.StrArr = nil

	if m.Test != nil {
		m.Test.ResetEx()
	} else {
		m.Test = Get_Test()
	}

	// m.IMap = map[int32]int32{}
	m.IMap = nil

	for _, i := range m.TestMap {
		Put_Test(i)
	}

	// m.TestMap = map[int32]*Test{}
	m.TestMap = nil

	m.Quest = 0

	// m.QuestMap = map[int64]E_Quest_Status{}
	m.QuestMap = nil

	// m.QuestSlice = []E_Quest_Status{}
	m.QuestSlice = nil

}

func (m User) Clone() *User {
	n, ok := g_User_Pool.Get().(*User)
	if !ok || n == nil {
		n = &User{}
	}

	n.ID = m.ID

	n.AccountID = m.AccountID

	n.ServerID = m.ServerID

	n.Name = m.Name

	n.Sex = m.Sex

	n.CreateTime = m.CreateTime

	if len(m.Arr) > 0 {
		n.Arr = make([]int32, len(m.Arr))
		copy(n.Arr, m.Arr)
	} else {
		// n.Arr = []int32{}
		n.Arr = nil
	}

	if len(m.StrArr) > 0 {
		n.StrArr = make([]string, len(m.StrArr))
		copy(n.StrArr, m.StrArr)
	} else {
		// n.StrArr = []string{}
		n.StrArr = nil
	}

	if m.Test != nil {
		n.Test = m.Test.Clone()
	}

	if len(m.IMap) > 0 {
		n.IMap = make(map[int32]int32, len(m.IMap))
		for i, e := range m.IMap {

			n.IMap[i] = e

		}
	} else {
		// n.IMap = map[int32]int32{}
		n.IMap = nil
	}

	if len(m.TestMap) > 0 {
		n.TestMap = make(map[int32]*Test, len(m.TestMap))
		for i, e := range m.TestMap {

			if e != nil {
				n.TestMap[i] = e.Clone()
			}

		}
	} else {
		// n.TestMap = map[int32]*Test{}
		n.TestMap = nil
	}

	n.Quest = m.Quest

	if len(m.QuestMap) > 0 {
		n.QuestMap = make(map[int64]E_Quest_Status, len(m.QuestMap))
		for i, e := range m.QuestMap {

			n.QuestMap[i] = e

		}
	} else {
		// n.QuestMap = map[int64]E_Quest_Status{}
		n.QuestMap = nil
	}

	if len(m.QuestSlice) > 0 {
		n.QuestSlice = make([]E_Quest_Status, len(m.QuestSlice))
		copy(n.QuestSlice, m.QuestSlice)
	} else {
		// n.QuestSlice = []E_Quest_Status{}
		n.QuestSlice = nil
	}

	return n
}

func Clone_User_Slice(dst []*User, src []*User) []*User {
	for _, i := range dst {
		Put_User(i)
	}
	if len(src) > 0 {
		dst = make([]*User, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		// dst = []*User{}
		dst = nil
	}
	return dst
}

func (sc SimpleClient) FindOne_User(ctx context.Context, query interface{}, opts ...options.FindOptions) (one *User, err error) {
	one = Get_User()
	err = sc.cli.Database.Collection(TblUser).Find(ctx, query, opts...).One(one)
	if err != nil {
		Put_User(one)
		return nil, err
	}
	return
}

func (sc SimpleClient) FindSome_User(ctx context.Context, query interface{}, opts ...options.FindOptions) (some []*User, err error) {
	some = []*User{}
	err = sc.cli.Database.Collection(TblUser).Find(ctx, query, opts...).All(&some)
	if err != nil {
		return nil, err
	}
	return
}

func (sc SimpleClient) UpdateSome_User(ctx context.Context, selector interface{}, update interface{}, opts ...options.UpdateOptions) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).UpdateAll(ctx, selector, update, opts...)
	return
}

func (sc SimpleClient) Upsert_User(ctx context.Context, selector interface{}, update interface{}, opts ...options.UpsertOptions) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).Upsert(ctx, selector, update, opts...)
	return
}

func (sc SimpleClient) UpsertID_User(ctx context.Context, id interface{}, update interface{}, opts ...options.UpsertOptions) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).UpsertId(ctx, id, update, opts...)
	return
}

func (m User) Insert(ctx context.Context, opts ...options.InsertOneOptions) (result *qmgo.InsertOneResult, err error) {
	return SC.cli.Database.Collection(TblUser).InsertOne(ctx, m, opts...)
}

func (m User) Update(ctx context.Context, selector interface{}, update interface{}, opts ...options.UpdateOptions) (err error) {
	return SC.cli.Database.Collection(TblUser).UpdateOne(ctx, selector, update, opts...)
}

func (m User) Upsert(ctx context.Context, selector interface{}, update interface{}, opts ...options.UpsertOptions) (result *qmgo.UpdateResult, err error) {
	return SC.cli.Database.Collection(TblUser).Upsert(ctx, selector, update, opts...)
}

func (m User) UpdateByObjID(id string) (err error) {
	return SC.cli.Database.Collection(TblUser).UpdateId(context.Background(), id, bson.D{{"$set", m}})
}

func (m User) RemoveByID() error {
	return SC.cli.Database.Collection(TblUser).RemoveId(context.Background(), m.ID)
}

func (m User) ToMsg(n *msg.User) *msg.User {
	if n == nil {
		n = msg.Get_User()
	}

	n.ID = m.ID

	n.AccountID = m.AccountID

	n.ServerID = m.ServerID

	n.Name = m.Name

	n.Sex = m.Sex

	n.CreateTime = m.CreateTime

	if len(m.Arr) > 0 {
		n.Arr = make([]int32, len(m.Arr))
		copy(n.Arr, m.Arr)
	} else {
		// n.Arr = []int32{}
		n.Arr = nil
	}

	if len(m.StrArr) > 0 {
		n.StrArr = make([]string, len(m.StrArr))
		copy(n.StrArr, m.StrArr)
	} else {
		// n.StrArr = []string{}
		n.StrArr = nil
	}

	if m.Test != nil {
		n.Test = m.Test.ToMsg(n.Test)
	}

	if len(m.IMap) > 0 {
		n.IMap = make(map[int32]int32, len(m.IMap))
		for i, e := range m.IMap {
			n.IMap[i] = e
		}
	} else {
		// n.IMap = map[int32]int32{}
		n.IMap = nil
	}

	if len(m.TestMap) > 0 {
		n.TestMap = make(map[int32]*msg.Test, len(m.TestMap))
		for i, e := range m.TestMap {
			if e != nil {
				n.TestMap[i] = e.ToMsg(n.TestMap[i])
			} else {
				n.TestMap[i] = msg.Get_Test()
			}
		}
	} else {
		// n.TestMap = map[int32]*Test{}
		n.TestMap = nil
	}

	n.Quest = msg.E_Quest_Status(m.Quest)

	if len(m.QuestMap) > 0 {
		n.QuestMap = make(map[int64]msg.E_Quest_Status, len(m.QuestMap))
		for i, e := range m.QuestMap {
			n.QuestMap[i] = msg.E_Quest_Status(e)
		}
	} else {
		// n.QuestMap = map[int64]E_Quest_Status{}
		n.QuestMap = nil
	}

	if len(m.QuestSlice) > 0 {
		for _, e := range m.QuestSlice {
			n.QuestSlice = append(n.QuestSlice, msg.E_Quest_Status(e))
		}
	} else {
		// n.QuestSlice = []E_Quest_Status{}
		n.QuestSlice = nil
	}

	return n
}

var g_User_Pool = sync.Pool{}

func Get_User() *User {
	m, ok := g_User_Pool.Get().(*User)
	if !ok {
		m = New_User()
	} else {
		if m == nil {
			m = New_User()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_User(i interface{}) {
	if m, ok := i.(*User); ok && m != nil {
		g_User_Pool.Put(i)
	}
}

// collection [User] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
