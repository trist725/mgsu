// Code generated by protoc-gen-mgo-go. DO NOT EDIT IT!!!
// source: user.proto

package model

import (
	json "encoding/json"
	fmt "fmt"
	mgo "github.com/globalsign/mgo"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	mongodb "github.com/trist725/mgsu/db/mongodb"
	math "math"
	msg "mlgs/src/msg"
	sync "sync"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = msg.PH

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [Test] begin

func New_Test() *Test {
	m := &Test{}
	return m
}

func (m Test) JsonString() string {
	bs, _ := json.Marshal(m)
	return fmt.Sprintf("{\"Test\":%s}", string(bs))
}

func (m *Test) ResetEx() {

	m.I32 = 0

	m.U32 = 0

	m.Str = ""

}

func (m Test) Clone() *Test {
	n, ok := g_Test_Pool.Get().(*Test)
	if !ok || n == nil {
		n = &Test{}
	}

	n.I32 = m.I32

	n.U32 = m.U32

	n.Str = m.Str

	return n
}

func Clone_Test_Slice(dst []*Test, src []*Test) []*Test {
	for _, i := range dst {
		Put_Test(i)
	}
	if len(src) > 0 {
		dst = make([]*Test, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		//dst = []*Test{}
		dst = nil
	}
	return dst
}

func (m Test) ToMsg(n *msg.Test) *msg.Test {
	if n == nil {
		n = msg.Get_Test()
	}

	n.i = m.I32

	n.U32 = m.U32

	n.Str = m.Str

	return n
}

type TestMap map[int64]*Test

func ToTestMap(m map[int64]*Test) *TestMap {
	if m == nil {
		return nil
	}
	return (*TestMap)(&m)
}

func NewTestMap() (m *TestMap) {
	m = &TestMap{}
	return
}

func (m *TestMap) Get(key int64) (value *Test, ok bool) {
	value, ok = (*m)[key]
	return
}

func (m *TestMap) Set(key int64, value *Test) {
	(*m)[key] = value
}

func (m *TestMap) Add(key int64) (value *Test) {
	value = Get_Test()
	(*m)[key] = value
	return
}

func (m *TestMap) Remove(key int64) (removed bool) {
	if _, ok := (*m)[key]; ok {
		delete(*m, key)
		return true
	}
	return false
}

func (m *TestMap) RemoveOne(fn func(key int64, value *Test) (removed bool)) {
	for key, value := range *m {
		if fn(key, value) {
			delete(*m, key)
			break
		}
	}
}

func (m *TestMap) RemoveSome(fn func(key int64, value *Test) (removed bool)) {
	left := map[int64]*Test{}
	for key, value := range *m {
		if !fn(key, value) {
			left[key] = value
		}
	}
	*m = left
}

func (m *TestMap) Each(f func(key int64, value *Test) (continued bool)) {
	for key, value := range *m {
		if !f(key, value) {
			break
		}
	}
}

func (m TestMap) Size() int {
	return len(m)
}

func (m TestMap) Clone() (n *TestMap) {
	if m.Size() == 0 {
		return nil
	}
	n = ToTestMap(make(map[int64]*Test, m.Size()))
	for k, v := range m {
		if v != nil {
			(*n)[k] = v.Clone()
		} else {
			(*n)[k] = nil
		}
	}
	return n
}

func (m *TestMap) Clear() {
	*m = *NewTestMap()
}

func (m TestMap) ToMsg(n map[int64]*msg.Test) map[int64]*msg.Test {
	if m.Size() == 0 {
		return nil
	}
	n = make(map[int64]*msg.Test, m.Size())
	for k, v := range m {
		if v != nil {
			n[k] = v.ToMsg(nil)
		} else {
			n[k] = msg.Get_Test()
		}
	}
	return n
}

type TestSlice []*Test

func NewTestSlice() *TestSlice {
	return &TestSlice{}
}

func ToTestSlice(s []*Test) *TestSlice {
	return (*TestSlice)(&s)
}

func (s *TestSlice) Add() *Test {
	return s.AddOne(Get_Test())
}

func (s *TestSlice) AddOne(newOne *Test) *Test {
	*s = append(*s, newOne)
	return newOne
}

func (s *TestSlice) RemoveOne(fn func(index int, element *Test) (removed bool)) {
	for i, e := range *s {
		if fn(i, e) {
			*s = append((*s)[:i], (*s)[i+1:]...)
			break
		}
	}
}

func (s *TestSlice) RemoveSome(fn func(index int, element *Test) (removed bool)) {
	var left []*Test
	for i, e := range *s {
		if !fn(i, e) {
			left = append(left, e)
		}
	}
	*s = left
}

func (s TestSlice) Each(fn func(index int, element *Test) (continued bool)) {
	for i, e := range s {
		if !fn(i, e) {
			break
		}
	}
}

func (s TestSlice) Size() int {
	return len(s)
}

func (s TestSlice) Clone() (n *TestSlice) {
	if s.Size() == 0 {
		return nil
	}
	n = ToTestSlice(make([]*Test, s.Size()))
	for i, e := range s {
		if e != nil {
			(*n)[i] = e.Clone()
		} else {
			(*n)[i] = nil
		}
	}
	return n
}

func (s *TestSlice) Clear() {
	*s = *NewTestSlice()
}

func (s TestSlice) ToMsg(n []*msg.Test) []*msg.Test {
	if s.Size() == 0 {
		return nil
	}
	n = make([]*msg.Test, s.Size())
	for i, e := range s {
		if e != nil {
			n[i] = e.ToMsg(nil)
		} else {
			n[i] = msg.Get_Test()
		}
	}
	return n
}

var g_Test_Pool = sync.Pool{}

func Get_Test() *Test {
	m, ok := g_Test_Pool.Get().(*Test)
	if !ok {
		m = New_Test()
	} else {
		if m == nil {
			m = New_Test()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_Test(i interface{}) {
	if m, ok := i.(*Test); ok && m != nil {
		g_Test_Pool.Put(i)
	}
}

// collection [Test] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [User] begin

func New_User() *User {
	m := &User{

		Test: Get_Test(),
	}
	return m
}

func (m User) JsonString() string {
	bs, _ := json.Marshal(m)
	return fmt.Sprintf("{\"User\":%s}", string(bs))
}

func (m *User) ResetEx() {

	m.ID = 0

	m.AccountID = 0

	m.ServerID = 0

	m.Name = ""

	m.Sex = 0

	m.CreateTime = 0

	//m.Arr = []int32{}
	m.Arr = nil

	//m.StrArr = []string{}
	m.StrArr = nil

	if m.Test != nil {
		m.Test.ResetEx()
	} else {
		m.Test = Get_Test()
	}

	//m.IMap = map[int32]int32{}
	m.IMap = nil

	for _, i := range m.TestMap {
		Put_Test(i)
	}

	//m.TestMap = map[int32]*Test{}
	m.TestMap = nil

}

func (m User) Clone() *User {
	n, ok := g_User_Pool.Get().(*User)
	if !ok || n == nil {
		n = &User{}
	}

	n.ID = m.ID

	n.AccountID = m.AccountID

	n.ServerID = m.ServerID

	n.Name = m.Name

	n.Sex = m.Sex

	n.CreateTime = m.CreateTime

	if len(m.Arr) > 0 {
		n.Arr = make([]int32, len(m.Arr))
		copy(n.Arr, m.Arr)
	} else {
		//n.Arr = []int32{}
		n.Arr = nil
	}

	if len(m.StrArr) > 0 {
		n.StrArr = make([]string, len(m.StrArr))
		copy(n.StrArr, m.StrArr)
	} else {
		//n.StrArr = []string{}
		n.StrArr = nil
	}

	if m.Test != nil {
		n.Test = m.Test.Clone()
	}

	if len(m.IMap) > 0 {
		n.IMap = make(map[int32]int32, len(m.IMap))
		for i, e := range m.IMap {

			n.IMap[i] = e

		}
	} else {
		//n.IMap = map[int32]int32{}
		n.IMap = nil
	}

	if len(m.TestMap) > 0 {
		n.TestMap = make(map[int32]*Test, len(m.TestMap))
		for i, e := range m.TestMap {

			if e != nil {
				n.TestMap[i] = e.Clone()
			}

		}
	} else {
		//n.TestMap = map[int32]*Test{}
		n.TestMap = nil
	}

	return n
}

func Clone_User_Slice(dst []*User, src []*User) []*User {
	for _, i := range dst {
		Put_User(i)
	}
	if len(src) > 0 {
		dst = make([]*User, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		//dst = []*User{}
		dst = nil
	}
	return dst
}

func (sc SimpleClient) FindOne_User(session *mongodb.Session, query interface{}) (one *User, err error) {
	one = Get_User()
	err = session.DB(sc.dbName).C(TblUser).Find(query).One(one)
	if err != nil {
		Put_User(one)
		return nil, err
	}
	return
}

func (sc SimpleClient) FindSome_User(session *mongodb.Session, query interface{}) (some []*User, err error) {
	some = []*User{}
	err = session.DB(sc.dbName).C(TblUser).Find(query).All(&some)
	if err != nil {
		return nil, err
	}
	return
}

func (sc SimpleClient) UpdateSome_User(session *mongodb.Session, selector interface{}, update interface{}) (info *mgo.ChangeInfo, err error) {
	info, err = session.DB(sc.dbName).C(TblUser).UpdateAll(selector, update)
	return
}

func (sc SimpleClient) Upsert_User(session *mongodb.Session, selector interface{}, update interface{}) (info *mgo.ChangeInfo, err error) {
	info, err = session.DB(sc.dbName).C(TblUser).Upsert(selector, update)
	return
}

func (sc SimpleClient) UpsertID_User(session *mongodb.Session, id interface{}, update interface{}) (info *mgo.ChangeInfo, err error) {
	info, err = session.DB(sc.dbName).C(TblUser).UpsertId(id, update)
	return
}

func (m User) Insert(session *mongodb.Session, dbName string) error {
	return session.DB(dbName).C(TblUser).Insert(m)
}

func (m User) Update(session *mongodb.Session, dbName string, selector interface{}, update interface{}) error {
	return session.DB(dbName).C(TblUser).Update(selector, update)
}

func (m User) UpdateByID(session *mongodb.Session, dbName string) error {
	return session.DB(dbName).C(TblUser).UpdateId(m.ID, m)
}

func (m User) RemoveByID(session *mongodb.Session, dbName string) error {
	return session.DB(dbName).C(TblUser).RemoveId(m.ID)
}

func (m User) ToMsg(n *msg.User) *msg.User {
	if n == nil {
		n = msg.Get_User()
	}

	n.ID = m.ID

	n.AccountID = m.AccountID

	n.ServerID = m.ServerID

	n.Name = m.Name

	n.Sex = m.Sex

	n.CreateTime = m.CreateTime

	if len(m.Arr) > 0 {
		n.Arr = make([]int32, len(m.Arr))
		copy(n.Arr, m.Arr)
	} else {
		//n.Arr = []int32{}
		n.Arr = nil
	}

	if len(m.StrArr) > 0 {
		n.StrArr = make([]string, len(m.StrArr))
		copy(n.StrArr, m.StrArr)
	} else {
		//n.StrArr = []string{}
		n.StrArr = nil
	}

	if m.Test != nil {
		n.Test = m.Test.ToMsg(n.Test)
	}

	if len(m.IMap) > 0 {

		n.IMap = make(map[int32]int32, len(m.IMap))
		for i, e := range m.IMap {
			n.IMap[i] = e
		}

	} else {
		//n.IMap = map[int32]int32{}
		n.IMap = nil
	}

	if len(m.TestMap) > 0 {

		n.TestMap = make(map[int32]*msg.Test, len(m.TestMap))
		for i, e := range m.TestMap {
			if e != nil {
				n.TestMap[i] = e.ToMsg(n.TestMap[i])
			} else {
				n.TestMap[i] = msg.Get_Test()
			}
		}

	} else {
		//n.TestMap = map[int32]*Test{}
		n.TestMap = nil
	}

	return n
}

var g_User_Pool = sync.Pool{}

func Get_User() *User {
	m, ok := g_User_Pool.Get().(*User)
	if !ok {
		m = New_User()
	} else {
		if m == nil {
			m = New_User()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_User(i interface{}) {
	if m, ok := i.(*User); ok && m != nil {
		g_User_Pool.Put(i)
	}
}

// collection [User] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
