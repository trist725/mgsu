// Code generated by protoc-gen-mgo-go. DO NOT EDIT IT!!!
// source: user.proto

package model

import (
	"context"
	json "encoding/json"
	fmt "fmt"
	math "math"

	sync "sync"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	qmgo "github.com/qiniu/qmgo"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = json.Marshal

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [Test] begin

func New_Test() *Test {
	m := &Test{}
	return m
}

func (m Test) JsonString() string {
	ba, _ := json.Marshal(m)
	return "Test:" + string(ba)
}

func (m *Test) ResetEx() {

	m.I32 = 0

	m.U32 = 0

	m.Str = ""

}

func (m Test) Clone() *Test {
	n, ok := g_Test_Pool.Get().(*Test)
	if !ok || n == nil {
		n = &Test{}
	}

	n.I32 = m.I32

	n.U32 = m.U32

	n.Str = m.Str

	return n
}

func Clone_Test_Slice(dst []*Test, src []*Test) []*Test {
	for _, i := range dst {
		Put_Test(i)
	}
	if len(src) > 0 {
		dst = make([]*Test, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		//dst = []*Test{}
		dst = nil
	}
	return dst
}

type TestMap map[int64]*Test

func ToTestMap(m map[int64]*Test) *TestMap {
	if m == nil {
		return nil
	}
	return (*TestMap)(&m)
}

func NewTestMap() (m *TestMap) {
	m = &TestMap{}
	return
}

func (m *TestMap) Get(key int64) (value *Test, ok bool) {
	value, ok = (*m)[key]
	return
}

func (m *TestMap) Set(key int64, value *Test) {
	(*m)[key] = value
}

func (m *TestMap) Add(key int64) (value *Test) {
	value = Get_Test()
	(*m)[key] = value
	return
}

func (m *TestMap) Remove(key int64) (removed bool) {
	if _, ok := (*m)[key]; ok {
		delete(*m, key)
		return true
	}
	return false
}

func (m *TestMap) RemoveOne(fn func(key int64, value *Test) (removed bool)) {
	for key, value := range *m {
		if fn(key, value) {
			delete(*m, key)
			break
		}
	}
}

func (m *TestMap) RemoveSome(fn func(key int64, value *Test) (removed bool)) {
	left := map[int64]*Test{}
	for key, value := range *m {
		if !fn(key, value) {
			left[key] = value
		}
	}
	*m = left
}

func (m *TestMap) Each(f func(key int64, value *Test) (continued bool)) {
	for key, value := range *m {
		if !f(key, value) {
			break
		}
	}
}

func (m TestMap) Size() int {
	return len(m)
}

func (m TestMap) Clone() (n *TestMap) {
	if m.Size() == 0 {
		return nil
	}
	n = ToTestMap(make(map[int64]*Test, m.Size()))
	for k, v := range m {
		if v != nil {
			(*n)[k] = v.Clone()
		} else {
			(*n)[k] = nil
		}
	}
	return n
}

func (m *TestMap) Clear() {
	*m = *NewTestMap()
}

type TestSlice []*Test

func NewTestSlice() *TestSlice {
	return &TestSlice{}
}

func ToTestSlice(s []*Test) *TestSlice {
	return (*TestSlice)(&s)
}

func (s *TestSlice) Add() *Test {
	return s.AddOne(Get_Test())
}

func (s *TestSlice) AddOne(newOne *Test) *Test {
	*s = append(*s, newOne)
	return newOne
}

func (s *TestSlice) RemoveOne(fn func(index int, element *Test) (removed bool)) {
	for i, e := range *s {
		if fn(i, e) {
			*s = append((*s)[:i], (*s)[i+1:]...)
			break
		}
	}
}

func (s *TestSlice) RemoveSome(fn func(index int, element *Test) (removed bool)) {
	var left []*Test
	for i, e := range *s {
		if !fn(i, e) {
			left = append(left, e)
		}
	}
	*s = left
}

func (s TestSlice) Each(fn func(index int, element *Test) (continued bool)) {
	for i, e := range s {
		if !fn(i, e) {
			break
		}
	}
}

func (s TestSlice) Size() int {
	return len(s)
}

func (s TestSlice) Clone() (n *TestSlice) {
	if s.Size() == 0 {
		return nil
	}
	n = ToTestSlice(make([]*Test, s.Size()))
	for i, e := range s {
		if e != nil {
			(*n)[i] = e.Clone()
		} else {
			(*n)[i] = nil
		}
	}
	return n
}

func (s *TestSlice) Clear() {
	*s = *NewTestSlice()
}

var g_Test_Pool = sync.Pool{}

func Get_Test() *Test {
	m, ok := g_Test_Pool.Get().(*Test)
	if !ok {
		m = New_Test()
	} else {
		if m == nil {
			m = New_Test()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_Test(i interface{}) {
	if m, ok := i.(*Test); ok && m != nil {
		g_Test_Pool.Put(i)
	}
}

// collection [Test] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// collection [User] begin

func New_User() *User {
	m := &User{

		Test: Get_Test(),
	}
	return m
}

func (m User) JsonString() string {
	ba, _ := json.Marshal(m)
	return "User:" + string(ba)
}

func (m *User) ResetEx() {

	m.ID = 0

	m.AccountID = 0

	m.ServerID = 0

	m.Name = ""

	m.Sex = 0

	m.CreateTime = 0

	//m.Arr = []int32{}
	m.Arr = nil

	//m.StrArr = []string{}
	m.StrArr = nil

	if m.Test != nil {
		m.Test.ResetEx()
	} else {
		m.Test = Get_Test()
	}

	//m.IMap = map[int32]int32{}
	m.IMap = nil

	for _, i := range m.TestMap {
		Put_Test(i)
	}

	//m.TestMap = map[int32]*Test{}
	m.TestMap = nil

}

func (m User) Clone() *User {
	n, ok := g_User_Pool.Get().(*User)
	if !ok || n == nil {
		n = &User{}
	}

	n.ID = m.ID

	n.AccountID = m.AccountID

	n.ServerID = m.ServerID

	n.Name = m.Name

	n.Sex = m.Sex

	n.CreateTime = m.CreateTime

	if len(m.Arr) > 0 {
		n.Arr = make([]int32, len(m.Arr))
		copy(n.Arr, m.Arr)
	} else {
		//n.Arr = []int32{}
		n.Arr = nil
	}

	if len(m.StrArr) > 0 {
		n.StrArr = make([]string, len(m.StrArr))
		copy(n.StrArr, m.StrArr)
	} else {
		//n.StrArr = []string{}
		n.StrArr = nil
	}

	if m.Test != nil {
		n.Test = m.Test.Clone()
	}

	if len(m.IMap) > 0 {
		n.IMap = make(map[int32]int32, len(m.IMap))
		for i, e := range m.IMap {

			n.IMap[i] = e

		}
	} else {
		//n.IMap = map[int32]int32{}
		n.IMap = nil
	}

	if len(m.TestMap) > 0 {
		n.TestMap = make(map[int32]*Test, len(m.TestMap))
		for i, e := range m.TestMap {

			if e != nil {
				n.TestMap[i] = e.Clone()
			}

		}
	} else {
		//n.TestMap = map[int32]*Test{}
		n.TestMap = nil
	}

	return n
}

func Clone_User_Slice(dst []*User, src []*User) []*User {
	for _, i := range dst {
		Put_User(i)
	}
	if len(src) > 0 {
		dst = make([]*User, len(src))
		for i, e := range src {
			if e != nil {
				dst[i] = e.Clone()
			}
		}
	} else {
		//dst = []*User{}
		dst = nil
	}
	return dst
}

func (sc SimpleClient) FindOne_User(query interface{}) (one *User, err error) {
	one = Get_User()
	err = sc.cli.Database.Collection(TblUser).Find(context.Background(), query).One(one)
	if err != nil {
		Put_User(one)
		return nil, err
	}
	return
}

func (sc SimpleClient) FindSome_User(query interface{}) (some []*User, err error) {
	some = []*User{}
	err = sc.cli.Database.Collection(TblUser).Find(context.Background(), query).All(&some)
	if err != nil {
		return nil, err
	}
	return
}

func (sc SimpleClient) UpdateSome_User(selector interface{}, update interface{}) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).UpdateAll(context.Background(), selector, update)
	return
}

func (sc SimpleClient) Upsert_User(selector interface{}, update interface{}) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).Upsert(context.Background(), selector, update)
	return
}

func (sc SimpleClient) UpsertID_User(id interface{}, update interface{}) (result *qmgo.UpdateResult, err error) {
	result, err = sc.cli.Database.Collection(TblUser).UpsertId(context.Background(), id, update)
	return
}

func (m User) Insert() (result *qmgo.InsertOneResult, err error) {
	return SC.cli.Database.Collection(TblUser).InsertOne(context.Background(), m)
}

func (m User) Update(selector interface{}, update interface{}) (err error) {
	return SC.cli.Database.Collection(TblUser).UpdateOne(context.Background(), selector, update)
}

func (m User) UpdateByID() (err error) {
	return SC.cli.Database.Collection(TblUser).UpdateId(context.Background(), m.ID, m)
}

func (m User) RemoveByID() error {
	return SC.cli.Database.Collection(TblUser).RemoveId(context.Background(), m.ID)
}

var g_User_Pool = sync.Pool{}

func Get_User() *User {
	m, ok := g_User_Pool.Get().(*User)
	if !ok {
		m = New_User()
	} else {
		if m == nil {
			m = New_User()
		} else {
			m.ResetEx()
		}
	}
	return m
}

func Put_User(i interface{}) {
	if m, ok := i.(*User); ok && m != nil {
		g_User_Pool.Put(i)
	}
}

// collection [User] end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
